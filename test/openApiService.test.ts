import { generateOpenApiSpec } from "../services/openApiService";
import { MockEndpoint, HttpMethod, Project } from "../types";

function test(name: string, fn: () => void) {
  try {
    fn();
    console.log(`âœ… PASS: ${name}`);
  } catch (e) {
    console.log(`âŒ FAIL: ${name}`);
    console.log(`   ${(e as Error).message}`);
  }
}

function assert(condition: any, message: string) {
  if (!condition) throw new Error(message);
}

function assertEqual(actual: any, expected: any, message: string) {
  if (JSON.stringify(actual) !== JSON.stringify(expected)) {
    throw new Error(
      `${message} | Expected: ${JSON.stringify(
        expected
      )}, Got: ${JSON.stringify(actual)}`
    );
  }
}

console.log("ðŸ§ª Starting openApiService tests\n");

// Sample project
const testProject: Project = {
  id: "p1",
  name: "Test API",
  createdAt: Date.now(),
};

// Sample mocks
const sampleMocks: MockEndpoint[] = [
  {
    id: "m1",
    projectId: "p1",
    name: "Get All Users",
    path: "/users",
    method: HttpMethod.GET,
    statusCode: 200,
    delay: 0,
    responseBody: JSON.stringify([
      { id: 1, name: "Alice" },
    ]),
    isActive: true,
    version: "1",
    createdAt: Date.now(),
    requestCount: 0,
    headers: [],
  },
  {
    id: "m2",
    projectId: "p1",
    name: "Get User by ID",
    path: "/users/:id",
    method: HttpMethod.GET,
    statusCode: 200,
    delay: 0,
    responseBody: JSON.stringify({
      id: 1,
      name: "Alice"
    }),
    isActive: true,
    version: "1",
    createdAt: Date.now(),
    requestCount: 0,
    headers: [],
  },
  {
    id: "m3",
    projectId: "p1",
    name: "Create User",
    path: "/users",
    method: HttpMethod.POST,
    statusCode: 201,
    delay: 0,
    responseBody: JSON.stringify({
      id: 2,
      name: "Bob"
    }),
    isActive: true,
    version: "1",
    createdAt: Date.now(),
    requestCount: 0,
    headers: [],
  },
  {
    id: "m4",
    projectId: "p1",
    name: "Update User",
    path: "/users/:id",
    method: HttpMethod.PUT,
    statusCode: 200,
    delay: 0,
    responseBody: JSON.stringify({ id: 1, name: "Alice Updated" }),
    isActive: true,
    version: "1",
    createdAt: Date.now(),
    requestCount: 0,
    headers: [],
  },
  {
    id: "m5",
    projectId: "p1",
    name: "Delete User",
    path: "/users/:id",
    method: HttpMethod.DELETE,
    statusCode: 204,
    delay: 0,
    responseBody: JSON.stringify({}),
    isActive: true,
    version: "1",
    createdAt: Date.now(),
    requestCount: 0,
    headers: [],
  },
];

test("Generate spec contains openapi version 3.0.0", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  assertEqual(spec.openapi, "3.0.0", "OpenAPI version should be 3.0.0");
});

test("Generate spec contains info with title, description, version", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  assert(
    spec.info.title === "Test API",
    "Info title should match project name"
  );
  assert(
    spec.info.description === "Generated by Backend Studio",
    "Description should be set"
  );
  assert(spec.info.version === "1.0.0", "Version should be 1.0.0");
});

test("Generate spec contains servers with localhost:3000", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  assert(spec.servers && spec.servers.length > 0, "Should have servers");
  assert(
    spec.servers[0].url === "http://localhost:3000",
    "Server URL should be localhost:3000"
  );
});

test("Paths are converted from :id to {id}", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  assert(spec.paths["/users/{id}"], "Should have /users/{id} path");
  assert(!spec.paths["/users/:id"], "Should not have /users/:id path");
});

test("All active endpoints are included in paths", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  assert(spec.paths["/users"], "Should have /users path");
  assert(spec.paths["/users/{id}"], "Should have /users/{id} path");
});

test("GET endpoint maps to correct method in paths", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  assert(spec.paths["/users"].get, "Should have GET method on /users");
  assert(
    spec.paths["/users/{id}"].get,
    "Should have GET method on /users/{id}"
  );
});

test("POST endpoint has requestBody with schema and example", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const postOp = spec.paths["/users"].post;
  assert(postOp, "Should have POST method on /users");
  assert(postOp.requestBody, "POST should have requestBody");
  assert(
    postOp.requestBody.content["application/json"],
    "Should have JSON content"
  );
  assert(
    postOp.requestBody.content["application/json"].schema,
    "Should have schema"
  );
  assert(
    postOp.requestBody.content["application/json"].example,
    "Should have example"
  );
});

test("PUT endpoint has requestBody with schema and example", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const putOp = spec.paths["/users/{id}"].put;
  assert(putOp, "Should have PUT method on /users/{id}");
  assert(putOp.requestBody, "PUT should have requestBody");
});

test("Path parameters are included with descriptions", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const getOp = spec.paths["/users/{id}"].get;
  assert(getOp.parameters, "Should have parameters");
  assert(getOp.parameters.length > 0, "Should have at least one parameter");
  const idParam = getOp.parameters.find((p: any) => p.name === "id");
  assert(idParam, "Should have id parameter");
  assert(idParam.in === "path", "id should be path parameter");
  assert(idParam.required === true, "id should be required");
  assert(idParam.description, "Parameter should have description");
});

test("Response status codes are mapped correctly", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  assert(
    spec.paths["/users"].get.responses[200],
    "GET /users should have 200 response"
  );
  assert(
    spec.paths["/users"].post.responses[201],
    "POST /users should have 201 response"
  );
  assert(
    spec.paths["/users/{id}"].delete.responses[204],
    "DELETE /users/{id} should have 204 response"
  );
});

test("Response descriptions are human-readable", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const getResp = spec.paths["/users"].get.responses[200];
  assert(getResp.description, "Response should have description");
  assert(
    getResp.description.includes("200") || getResp.description.includes("OK"),
    "Description should mention status or outcome"
  );
});

test("Response includes application/json content with schema and example", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const getResp = spec.paths["/users"].get.responses[200];
  assert(getResp.content, "Response should have content");
  assert(getResp.content["application/json"], "Should have JSON content");
  assert(getResp.content["application/json"].schema, "Should have schema");
  assert(getResp.content["application/json"].example, "Should have example");
});

test("Schema infers array type from array responses", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const getResp = spec.paths["/users"].get.responses[200];
  assert(
    getResp.content["application/json"].schema.type === "array",
    "Array response should be type array"
  );
  assert(
    getResp.content["application/json"].schema.items,
    "Array should have items schema"
  );
});

test("Schema infers object type from object responses", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const getResp = spec.paths["/users/{id}"].get.responses[200];
  assert(
    getResp.content["application/json"].schema.type === "object",
    "Object response should be type object"
  );
  assert(
    getResp.content["application/json"].schema.properties,
    "Object should have properties"
  );
});

test("Operation has summary with endpoint name", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const getOp = spec.paths["/users"].get;
  assert(getOp.summary === "Get All Users", "Summary should match mock name");
});

test("Operation has description with method and path", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const getOp = spec.paths["/users"].get;
  assert(getOp.description, "Operation should have description");
  assert(
    getOp.description.includes("GET") || getOp.description.includes("/users"),
    "Description should mention method or path"
  );
});

test("Operation has tags for grouping", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const getOp = spec.paths["/users"].get;
  assert(getOp.tags, "Operation should have tags");
  assert(getOp.tags.length > 0, "Should have at least one tag");
});

test("Inactive endpoints are excluded from spec", () => {
  const inactiveMock = { ...sampleMocks[0], isActive: false };
  const spec = generateOpenApiSpec(testProject, [
    inactiveMock,
    ...sampleMocks.slice(1),
  ]);
  assert(
    !spec.paths["/users"]?.get || spec.paths["/users"]?.get !== inactiveMock,
    "Inactive endpoint should not be included"
  );
});

test("Only endpoints for active project are included", () => {
  const differentProjectMock = { ...sampleMocks[0], projectId: "p2" };
  const spec = generateOpenApiSpec(testProject, [
    differentProjectMock,
    ...sampleMocks,
  ]);
  // Should still include the active ones from p1
  assert(
    spec.paths["/users"] && spec.paths["/users"].get,
    "Should include endpoints from active project"
  );
});

test("Spec has components object for future schema definitions", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  assert(spec.components, "Spec should have components");
  assert(
    spec.components.schemas !== undefined,
    "Spec should have schemas in components"
  );
});

test("DELETE responses handle empty body correctly", () => {
  const spec = generateOpenApiSpec(testProject, sampleMocks);
  const deleteResp = spec.paths["/users/{id}"].delete.responses[204];
  assert(
    deleteResp.content["application/json"],
    "Should have JSON content even for empty responses"
  );
  assert(deleteResp.content["application/json"].schema, "Should have schema");
});

console.log("\nðŸ§ª openApiService tests completed\n");
