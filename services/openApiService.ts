
import { MockEndpoint, Project } from "../types";

// Helper to convert internal path "/users/:id" to OpenAPI path "/users/{id}"
const convertPathToOpenApi = (path: string) => {
  return path.replace(/:([a-zA-Z0-9_]+)/g, '{$1}');
};

// Helper to extract parameters from path
const extractPathParams = (path: string) => {
  const matches = path.match(/:([a-zA-Z0-9_]+)/g);
  if (!matches) return [];
  return matches.map(m => ({
    name: m.substring(1),
    in: 'path',
    required: true,
    schema: { type: 'string' }
  }));
};

// Helper to infer JSON Schema from a value (Recursive)
const inferSchema = (data: any): any => {
  if (data === null) return { type: 'string', nullable: true };
  
  const type = typeof data;
  
  if (Array.isArray(data)) {
    const itemSchema = data.length > 0 ? inferSchema(data[0]) : { type: 'string' };
    return {
      type: 'array',
      items: itemSchema
    };
  }
  
  if (type === 'object') {
    const properties: any = {};
    Object.keys(data).forEach(key => {
      properties[key] = inferSchema(data[key]);
    });
    return {
      type: 'object',
      properties
    };
  }

  if (type === 'number') return { type: Number.isInteger(data) ? 'integer' : 'number' };
  if (type === 'boolean') return { type: 'boolean' };
  
  // Default to string (handles dynamic variables like {{$uuid}})
  return { type: 'string', example: data };
};

export const generateOpenApiSpec = (project: Project, mocks: MockEndpoint[]) => {
  const activeMocks = mocks.filter(m => m.isActive && m.projectId === project.id);
  
  const paths: any = {};

  activeMocks.forEach(mock => {
    const openApiPath = convertPathToOpenApi(mock.path);
    
    if (!paths[openApiPath]) {
      paths[openApiPath] = {};
    }

    const pathParams = extractPathParams(mock.path);
    
    let schema = { type: 'object' };
    let example = {};
    
    try {
      example = JSON.parse(mock.responseBody);
      schema = inferSchema(example);
    } catch (e) {
      // If response body is not valid JSON, treat as plain text/string
      schema = { type: 'string' };
    }

    paths[openApiPath][mock.method.toLowerCase()] = {
      summary: mock.name,
      parameters: pathParams,
      responses: {
        [mock.statusCode]: {
          description: "Successful response",
          content: {
            "application/json": {
              schema: schema,
              example: example
            }
          }
        }
      }
    };
    
    // Add request body for POST/PUT/PATCH
    if (['POST', 'PUT', 'PATCH'].includes(mock.method)) {
        paths[openApiPath][mock.method.toLowerCase()].requestBody = {
            required: true,
            content: {
                "application/json": {
                    schema: {
                        type: "object",
                        properties: {
                            key: { type: "string", example: "value" }
                        }
                    }
                }
            }
        };
    }
  });

  return {
    openapi: "3.0.0",
    info: {
      title: project.name,
      description: "Generated by Backend Studio",
      version: "1.0.0"
    },
    servers: [
      {
        url: "http://localhost:3000",
        description: "Local Development Server"
      }
    ],
    paths: paths
  };
};
